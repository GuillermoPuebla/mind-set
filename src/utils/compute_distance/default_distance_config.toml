[run_info]
type = ""

# If you are using the "folders vs folders" setup, then [folder] is the path to the parent folder containing all other folders, and [base_name] is the path  of the FOLDER containing all base images. [base_name] does NOT need to be a subfolder in [folder].
# If you are using the "base image vs folder", then [base_name] is the path of the IMAGE against which all other images in the [folder] will be compared against.
 # See README for details.
[input_paths]
folder= ""
base_name = ""

[options]
# Either [euclidean] or [cossim], default=euclidean"
distance_metric = "euclidean"
network_name = "resnet152"
# Specify against what layer we want to compute the cosine similarity analysis"
save_layers = ["Conv2d", "Linear"]
gpu_num = 0
# either ImageNet of Vanilla
pretraining = "ImageNet"

[saving_folders]
result_folder = "results/tmp"

[transformation]
# Specify what transformation to apply. Use t/s/r for translation, scale and rotation, and square brackets with the transformation limits. E.g. t[-0.2, 0.2]r[-50, 50]s will translate from -0.2 to 0.2 (normalize to image size), rotate from -50 to +50 degrees, and s indicates that will scale using default values. Default values are t=[-0.2, 0.2], s=0.7, 1.3], r=[0, 360].
affine_transf_code = "t[-0.2, 0.2]r[-50, 50]"
# When rotating/scaling the image, a "fill in" background will be used. Specify it here with a tuple of ints from 0 to 255. Default is black: (0, 0, 0). [random] for randomly pixellated background is not supported yet.
affine_transf_background = [0, 0, 0]
# specify whether all members of a comparison set should have the same transformation applied to them (according to "affine_transf_code")
matching_transform = true
# How many times do we need to repeat a transformed sample. Only applies when you use some type of transformation. If no transformation specified, this is set to 1.
repetitions = 50

# Whether we want to copy the images found in the folders onto a bigger canvas. The canvas background will be `affine_transf_background`. The canvas will be `canvas_to_obj_ratio` along the horizontal dimension, and it will be a square.
copy_on_bigger_canvas = false
# Only used if `copy_on_bigger_canvas` is true.
canvas_to_image_ratio = 3
